{"ast":null,"code":"let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = atom => \"init\" in atom;\nconst isActuallyWritableAtom = atom => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {}).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = x => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = a => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = atomState => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  const getAtomState = atom => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(v => {\n          if (!settled) {\n            settled = true;\n            resolvePromise(promise, v);\n            resolve(v);\n            updatePromiseDependencies();\n          }\n        }, e => {\n          if (!settled) {\n            settled = true;\n            rejectPromise(promise, e);\n            reject(e);\n            updatePromiseDependencies();\n          }\n        });\n        continuePromise = next => {\n          if (!settled) {\n            settled = true;\n            next.then(v => resolvePromise(promise, v), e => rejectPromise(promise, e));\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, next => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */new Map();\n    let isSync = true;\n    const getter = a => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () => controller == null ? void 0 : controller.abort());\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = atom => returnAtomValue(readAtomState(atom));\n  const addAtom = atom => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = atom => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = atom => {\n    const getDependents = a => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */new Set();\n    const visit = n => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = a => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(l => l({\n            type: \"async-write\",\n            flushed\n          }));\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(l => l({\n        type: \"write\",\n        flushed\n      }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const {\n        onMount\n      } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach(f => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = atom => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !(\n          // TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(listener => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(l => l({\n        type: \"sub\",\n        flushed\n      }));\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach(l => l({\n          type: \"unsub\"\n        }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: a => atomStateMap.get(a),\n      dev_get_mounted: a => mountedMap.get(a),\n      dev_restore_atoms: values => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(l => l({\n          type: \"restore\",\n          flushed\n        }));\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexport { atom, createStore, getDefaultStore };","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","defaultRead","defaultWrite","get","set","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","next","resolvePromise","value","status","rejectPromise","e","reason","isPromiseLike","x","then","isEqualAtomValue","b","Object","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","isEqualPromiseAtomValue","orig","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","storeListenersRev2","mountedAtoms","import","meta","env","MODE","Set","getAtomState","setAtomState","freeze","prevAtomState","has","resolve","reject","updateDependencies","nextAtomState","nextDependencies","keepPreviousDependencies","dependencies","d","changed","forEach","aState","console","warn","size","setAtomValue","setAtomValueOrPromise","valueOrPromise","abortPromise","continuePromise","updatePromiseDependencies","mountDependencies","settled","setAtomError","error","readAtomState","force","Array","from","every","s","isSync","getter","aState2","Error","controller","setSelf","options","signal","AbortController","args","writeAtom","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","getDependents","_a","dependents","_","pendingAtom","_a2","add","topsortedAtoms","markedAtoms","visit","n","m","push","changedAtoms","i","length","hasChangedDeps","dep","keys","writeAtomState","setter","args2","r","flushed","flushPending","type","result","initialDependent","onMountQueue","queue","aMounted","onMount","onUnmount","u","f","prevDependencies","depSet","maybeUnmountAtomSet","pending","clear","listener","subscribeAtom","listeners","sub","dev_subscribe_store","rev","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","defaultStore","globalThis","__NUMBER_OF_JOTAI_INSTANCES__","getDefaultStore"],"sources":["/home/valentinalopez/Development/udeverso-react/client/node_modules/jotai/esm/vanilla.mjs"],"sourcesContent":["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let storeListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    storeListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      pendingMap.forEach((_, pendingAtom) => {\n        var _a2;\n        if ((_a2 = getAtomState(pendingAtom)) == null ? void 0 : _a2.d.has(a)) {\n          dependents.add(pendingAtom);\n        }\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending();\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"write\", flushed })\n      );\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom, queue);\n        }\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted && canUnmountAtom(a, mounted)) {\n        unmountAtom(a);\n      }\n    });\n  };\n  const flushPending = () => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          const mounted = mountedMap.get(atom);\n          if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n              flushed.add(atom);\n            }\n          }\n        } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    const flushed = flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        storeListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l, rev) => {\n        if (rev !== 2) {\n          throw new Error(\"The current StoreListener revision is 2.\");\n        }\n        storeListenersRev2.add(l);\n        return () => {\n          storeListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending();\n        storeListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nif ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n  if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n    ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n  } else {\n    globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n  }\n}\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n      console.warn(\n        \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n      );\n    }\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
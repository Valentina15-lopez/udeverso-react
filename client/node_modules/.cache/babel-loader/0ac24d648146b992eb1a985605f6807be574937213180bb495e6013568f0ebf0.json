{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\nclass EdgeSplitModifier {\n  modify(geometry, cutOffAngle, tryKeepNormals = true) {\n    function computeNormals() {\n      normals = new Float32Array(indexes.length * 3);\n      for (let i = 0; i < indexes.length; i += 3) {\n        let index = indexes[i];\n        _A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 1];\n        _B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 2];\n        _C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        _C.sub(_B);\n        _A.sub(_B);\n        const normal = _C.cross(_A).normalize();\n        for (let j = 0; j < 3; j++) {\n          normals[3 * (i + j)] = normal.x;\n          normals[3 * (i + j) + 1] = normal.y;\n          normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    }\n    function mapPositionsToIndexes() {\n      pointToIndexMap = Array(positions.length / 3);\n      for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n        if (pointToIndexMap[index] == null) {\n          pointToIndexMap[index] = [];\n        }\n        pointToIndexMap[index].push(i);\n      }\n    }\n    function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n      _A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (const j of indexes) {\n        if (j !== firstIndex) {\n          _B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n          if (_B.dot(_A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    }\n    function edgeSplit(indexes, cutOff, original = null) {\n      if (indexes.length === 0) return;\n      const groupResults = [];\n      for (const index of indexes) {\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (const groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        splitIndexes.push({\n          original: original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    }\n    let hadNormals = false;\n    let oldNormals = null;\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n      if (tryKeepNormals === true && geometry.index !== null) {\n        oldNormals = geometry.attributes.normal.array;\n      }\n      geometry.deleteAttribute('normal');\n    }\n    if (geometry.index == null) {\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n    const indexes = geometry.index.array;\n    const positions = geometry.getAttribute('position').array;\n    let normals;\n    let pointToIndexMap;\n    computeNormals();\n    mapPositionsToIndexes();\n    const splitIndexes = [];\n    for (const vertexIndexes of pointToIndexMap) {\n      edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n    }\n    const newAttributes = {};\n    for (const name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n    const newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n    for (let i = 0; i < splitIndexes.length; i++) {\n      const split = splitIndexes[i];\n      const index = indexes[split.original];\n      for (const attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n      for (const j of split.indexes) {\n        newIndexes[j] = indexes.length + i;\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    for (const name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n        for (const splitData of splitIndexes) changedNormals[splitData.original] = true;\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n    return geometry;\n  }\n}\nexport { EdgeSplitModifier };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","_A","_B","_C","EdgeSplitModifier","modify","geometry","cutOffAngle","tryKeepNormals","computeNormals","normals","Float32Array","indexes","length","i","index","set","positions","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","pointToIndexMap","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","dot","edgeSplit","original","groupResults","groupResult","splitIndexes","hadNormals","oldNormals","attributes","clone","array","deleteAttribute","mergeVertices","getAttribute","vertexIndexes","Math","cos","newAttributes","name","Object","keys","oldAttribute","newArray","constructor","itemSize","normalized","newIndexes","Uint32Array","split","attribute","values","setIndex","setAttribute","computeVertexNormals","changedNormals","fill","splitData"],"sources":["/home/valentinalopez/Development/udeverso-react/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\n\nclass EdgeSplitModifier {\n\n\tmodify( geometry, cutOffAngle, tryKeepNormals = true ) {\n\n\t\tfunction computeNormals() {\n\n\t\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\t\tlet index = indexes[ i ];\n\n\t\t\t\t_A.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 1 ];\n\t\t\t\t_B.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\tindex = indexes[ i + 2 ];\n\t\t\t\t_C.set(\n\t\t\t\t\tpositions[ 3 * index ],\n\t\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\t\t_C.sub( _B );\n\t\t\t\t_A.sub( _B );\n\n\t\t\t\tconst normal = _C.cross( _A ).normalize();\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction mapPositionsToIndexes() {\n\n\t\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\t\tfor ( let i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\tconst index = indexes[ i ];\n\n\t\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\t\t_A.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\t\tconst result = {\n\t\t\t\tsplitGroup: [],\n\t\t\t\tcurrentGroup: [ firstIndex ]\n\t\t\t};\n\n\t\t\tfor ( const j of indexes ) {\n\n\t\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\t\t_B.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\t\tif ( _B.dot( _A ) < cutOff ) {\n\n\t\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\t\tif ( indexes.length === 0 ) return;\n\n\t\t\tconst groupResults = [];\n\n\t\t\tfor ( const index of indexes ) {\n\n\t\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t\t}\n\n\t\t\tlet result = groupResults[ 0 ];\n\n\t\t\tfor ( const groupResult of groupResults ) {\n\n\t\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\t\tresult = groupResult;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( original != null ) {\n\n\t\t\t\tsplitIndexes.push( {\n\t\t\t\t\toriginal: original,\n\t\t\t\t\tindexes: result.currentGroup\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( result.splitGroup.length ) {\n\n\t\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet hadNormals = false;\n\t\tlet oldNormals = null;\n\n\t\tif ( geometry.attributes.normal ) {\n\n\t\t\thadNormals = true;\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t\tif ( tryKeepNormals === true && geometry.index !== null ) {\n\n\t\t\t\toldNormals = geometry.attributes.normal.array;\n\n\t\t\t}\n\n\t\t\tgeometry.deleteAttribute( 'normal' );\n\n\t\t}\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tconst indexes = geometry.index.array;\n\t\tconst positions = geometry.getAttribute( 'position' ).array;\n\n\t\tlet normals;\n\t\tlet pointToIndexMap;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\t\tconst splitIndexes = [];\n\n\t\tfor ( const vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tconst newAttributes = {};\n\t\tfor ( const name of Object.keys( geometry.attributes ) ) {\n\n\t\t\tconst oldAttribute = geometry.attributes[ name ];\n\t\t\tconst newArray = new oldAttribute.array.constructor( ( indexes.length + splitIndexes.length ) * oldAttribute.itemSize );\n\t\t\tnewArray.set( oldAttribute.array );\n\t\t\tnewAttributes[ name ] = new BufferAttribute( newArray, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t}\n\n\t\tconst newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( let i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tconst split = splitIndexes[ i ];\n\t\t\tconst index = indexes[ split.original ];\n\n\t\t\tfor ( const attribute of Object.values( newAttributes ) ) {\n\n\t\t\t\tfor ( let j = 0; j < attribute.itemSize; j ++ ) {\n\n\t\t\t\t\tattribute.array[ ( indexes.length + i ) * attribute.itemSize + j ] =\n\t\t\t\t\t\tattribute.array[ index * attribute.itemSize + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = indexes.length + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\tfor ( const name of Object.keys( newAttributes ) ) {\n\n\t\t\tgeometry.setAttribute( name, newAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( hadNormals ) {\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tif ( oldNormals !== null ) {\n\n\t\t\t\tconst changedNormals = new Array( oldNormals.length / 3 ).fill( false );\n\n\t\t\t\tfor ( const splitData of splitIndexes )\n\t\t\t\t\tchangedNormals[ splitData.original ] = true;\n\n\t\t\t\tfor ( let i = 0; i < changedNormals.length; i ++ ) {\n\n\t\t\t\t\tif ( changedNormals[ i ] === false ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ )\n\t\t\t\t\t\t\tgeometry.attributes.normal.array[ 3 * i + j ] = oldNormals[ 3 * i + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n\nexport { EdgeSplitModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
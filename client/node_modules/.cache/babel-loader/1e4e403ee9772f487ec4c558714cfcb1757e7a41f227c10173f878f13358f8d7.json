{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Vector2, Vector3, Vector4 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nconst _cb = new Vector3(),\n  _ab = new Vector3();\nclass SimplifyModifier {\n  modify(geometry, count) {\n    geometry = geometry.clone();\n\n    // currently morphAttributes are not supported\n    delete geometry.morphAttributes.position;\n    delete geometry.morphAttributes.normal;\n    const attributes = geometry.attributes;\n\n    // this modifier can only process indexed and non-indexed geomtries with at least a position attribute\n\n    for (const name in attributes) {\n      if (name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color') geometry.deleteAttribute(name);\n    }\n    geometry = BufferGeometryUtils.mergeVertices(geometry);\n\n    //\n    // put data of original geometry in different data structures\n    //\n\n    const vertices = [];\n    const faces = [];\n\n    // add vertices\n\n    const positionAttribute = geometry.getAttribute('position');\n    const uvAttribute = geometry.getAttribute('uv');\n    const normalAttribute = geometry.getAttribute('normal');\n    const tangentAttribute = geometry.getAttribute('tangent');\n    const colorAttribute = geometry.getAttribute('color');\n    let t = null;\n    let v2 = null;\n    let nor = null;\n    let col = null;\n    for (let i = 0; i < positionAttribute.count; i++) {\n      const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n      if (uvAttribute) {\n        v2 = new Vector2().fromBufferAttribute(uvAttribute, i);\n      }\n      if (normalAttribute) {\n        nor = new Vector3().fromBufferAttribute(normalAttribute, i);\n      }\n      if (tangentAttribute) {\n        t = new Vector4().fromBufferAttribute(tangentAttribute, i);\n      }\n      if (colorAttribute) {\n        col = new THREE.Color().fromBufferAttribute(colorAttribute, i);\n      }\n      const vertex = new Vertex(v, v2, nor, t, col);\n      vertices.push(vertex);\n    }\n\n    // add faces\n\n    let index = geometry.getIndex();\n    if (index !== null) {\n      for (let i = 0; i < index.count; i += 3) {\n        const a = index.getX(i);\n        const b = index.getX(i + 1);\n        const c = index.getX(i + 2);\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n        faces.push(triangle);\n      }\n    } else {\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        const a = i;\n        const b = i + 1;\n        const c = i + 2;\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n        faces.push(triangle);\n      }\n    }\n\n    // compute all edge collapse costs\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      computeEdgeCostAtVertex(vertices[i]);\n    }\n    let nextVertex;\n    let z = count;\n    while (z--) {\n      nextVertex = minimumCostEdge(vertices);\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex');\n        break;\n      }\n      collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n    }\n\n    //\n\n    const simplifiedGeometry = new BufferGeometry();\n    const position = [];\n    const uv = [];\n    const normal = [];\n    const tangent = [];\n    const color = [];\n    index = [];\n\n    //\n\n    for (let i = 0; i < vertices.length; i++) {\n      const vertex = vertices[i];\n      position.push(vertex.position.x, vertex.position.y, vertex.position.z);\n      if (vertex.uv) {\n        uv.push(vertex.uv.x, vertex.uv.y);\n      }\n      if (vertex.normal) {\n        normal.push(vertex.normal.x, vertex.normal.y, vertex.normal.z);\n      }\n      if (vertex.tangent) {\n        tangent.push(vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w);\n      }\n      if (vertex.color) {\n        color.push(vertex.color.r, vertex.color.g, vertex.color.b);\n      }\n\n      // cache final index to GREATLY speed up faces reconstruction\n      vertex.id = i;\n    }\n\n    //\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      index.push(face.v1.id, face.v2.id, face.v3.id);\n    }\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    if (uv.length > 0) simplifiedGeometry.setAttribute('uv', new Float32BufferAttribute(uv, 2));\n    if (normal.length > 0) simplifiedGeometry.setAttribute('normal', new Float32BufferAttribute(normal, 3));\n    if (tangent.length > 0) simplifiedGeometry.setAttribute('tangent', new Float32BufferAttribute(tangent, 4));\n    if (color.length > 0) simplifiedGeometry.setAttribute('color', new Float32BufferAttribute(color, 3));\n    simplifiedGeometry.setIndex(index);\n    return simplifiedGeometry;\n  }\n}\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nfunction computeEdgeCollapseCost(u, v) {\n  // if we collapse edge uv by moving u to v then how\n  // much different will the model change, i.e. the \"error\".\n\n  const edgelength = v.position.distanceTo(u.position);\n  let curvature = 0;\n  const sideFaces = [];\n\n  // find the \"sides\" triangles that are on the edge uv\n  for (let i = 0, il = u.faces.length; i < il; i++) {\n    const face = u.faces[i];\n    if (face.hasVertex(v)) {\n      sideFaces.push(face);\n    }\n  }\n\n  // use the triangle facing most away from the sides\n  // to determine our curvature term\n  for (let i = 0, il = u.faces.length; i < il; i++) {\n    let minCurvature = 1;\n    const face = u.faces[i];\n    for (let j = 0; j < sideFaces.length; j++) {\n      const sideFace = sideFaces[j];\n      // use dot product of face normals.\n      const dotProd = face.normal.dot(sideFace.normal);\n      minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n    }\n    curvature = Math.max(curvature, minCurvature);\n  }\n\n  // crude approach in attempt to preserve borders\n  // though it seems not to be totally correct\n  const borders = 0;\n  if (sideFaces.length < 2) {\n    // we add some arbitrary cost for borders,\n    // borders += 10;\n    curvature = 1;\n  }\n  const amt = edgelength * curvature + borders;\n  return amt;\n}\nfunction computeEdgeCostAtVertex(v) {\n  // compute the edge collapse cost for all edges that start\n  // from vertex v.  Since we are only interested in reducing\n  // the object by selecting the min cost edge at each step, we\n  // only cache the cost of the least cost edge at this vertex\n  // (in member variable collapse) as well as the value of the\n  // cost (in member variable collapseCost).\n\n  if (v.neighbors.length === 0) {\n    // collapse if no neighbors.\n    v.collapseNeighbor = null;\n    v.collapseCost = -0.01;\n    return;\n  }\n  v.collapseCost = 100000;\n  v.collapseNeighbor = null;\n\n  // search all neighboring edges for \"least cost\" edge\n  for (let i = 0; i < v.neighbors.length; i++) {\n    const collapseCost = computeEdgeCollapseCost(v, v.neighbors[i]);\n    if (!v.collapseNeighbor) {\n      v.collapseNeighbor = v.neighbors[i];\n      v.collapseCost = collapseCost;\n      v.minCost = collapseCost;\n      v.totalCost = 0;\n      v.costCount = 0;\n    }\n    v.costCount++;\n    v.totalCost += collapseCost;\n    if (collapseCost < v.minCost) {\n      v.collapseNeighbor = v.neighbors[i];\n      v.minCost = collapseCost;\n    }\n  }\n\n  // we average the cost of collapsing at this vertex\n  v.collapseCost = v.totalCost / v.costCount;\n  // v.collapseCost = v.minCost;\n}\nfunction removeVertex(v, vertices) {\n  console.assert(v.faces.length === 0);\n  while (v.neighbors.length) {\n    const n = v.neighbors.pop();\n    removeFromArray(n.neighbors, v);\n  }\n  removeFromArray(vertices, v);\n}\nfunction removeFace(f, faces) {\n  removeFromArray(faces, f);\n  if (f.v1) removeFromArray(f.v1.faces, f);\n  if (f.v2) removeFromArray(f.v2.faces, f);\n  if (f.v3) removeFromArray(f.v3.faces, f);\n\n  // TODO optimize this!\n  const vs = [f.v1, f.v2, f.v3];\n  for (let i = 0; i < 3; i++) {\n    const v1 = vs[i];\n    const v2 = vs[(i + 1) % 3];\n    if (!v1 || !v2) continue;\n    v1.removeIfNonNeighbor(v2);\n    v2.removeIfNonNeighbor(v1);\n  }\n}\nfunction collapse(vertices, faces, u, v) {\n  // Collapse the edge uv by moving vertex u onto v\n\n  if (!v) {\n    // u is a vertex all by itself so just delete it..\n    removeVertex(u, vertices);\n    return;\n  }\n  if (v.uv) {\n    u.uv.copy(v.uv);\n  }\n  if (v.normal) {\n    v.normal.add(u.normal).normalize();\n  }\n  if (v.tangent) {\n    v.tangent.add(u.tangent).normalize();\n  }\n  const tmpVertices = [];\n  for (let i = 0; i < u.neighbors.length; i++) {\n    tmpVertices.push(u.neighbors[i]);\n  }\n\n  // delete triangles on edge uv:\n  for (let i = u.faces.length - 1; i >= 0; i--) {\n    if (u.faces[i] && u.faces[i].hasVertex(v)) {\n      removeFace(u.faces[i], faces);\n    }\n  }\n\n  // update remaining triangles to have v instead of u\n  for (let i = u.faces.length - 1; i >= 0; i--) {\n    u.faces[i].replaceVertex(u, v);\n  }\n  removeVertex(u, vertices);\n\n  // recompute the edge collapse costs in neighborhood\n  for (let i = 0; i < tmpVertices.length; i++) {\n    computeEdgeCostAtVertex(tmpVertices[i]);\n  }\n}\nfunction minimumCostEdge(vertices) {\n  // O(n * n) approach. TODO optimize this\n\n  let least = vertices[0];\n  for (let i = 0; i < vertices.length; i++) {\n    if (vertices[i].collapseCost < least.collapseCost) {\n      least = vertices[i];\n    }\n  }\n  return least;\n}\n\n// we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.normal = new Vector3();\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    _cb.subVectors(vC, vB);\n    _ab.subVectors(vA, vB);\n    _cb.cross(_ab).normalize();\n    this.normal.copy(_cb);\n  }\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n}\nclass Vertex {\n  constructor(v, uv, normal, tangent, color) {\n    this.position = v;\n    this.uv = uv;\n    this.normal = normal;\n    this.tangent = tangent;\n    this.color = color;\n    this.id = -1; // external use position in vertices list (for e.g. face generation)\n\n    this.faces = []; // faces vertex is connected\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n    // these will be computed in computeEdgeCostAtVertex()\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n    neighbors.splice(offset, 1);\n  }\n}\nexport { SimplifyModifier };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","Vector4","BufferGeometryUtils","_cb","_ab","SimplifyModifier","modify","geometry","count","clone","morphAttributes","position","normal","attributes","name","deleteAttribute","mergeVertices","vertices","faces","positionAttribute","getAttribute","uvAttribute","normalAttribute","tangentAttribute","colorAttribute","t","v2","nor","col","i","v","fromBufferAttribute","THREE","Color","vertex","Vertex","push","index","getIndex","a","getX","b","c","triangle","Triangle","il","length","computeEdgeCostAtVertex","nextVertex","z","minimumCostEdge","console","log","collapse","collapseNeighbor","simplifiedGeometry","uv","tangent","color","x","y","w","r","g","id","face","v1","v3","setAttribute","setIndex","pushIfUnique","array","object","indexOf","removeFromArray","k","splice","computeEdgeCollapseCost","u","edgelength","distanceTo","curvature","sideFaces","hasVertex","minCurvature","j","sideFace","dotProd","dot","Math","min","max","borders","amt","neighbors","collapseCost","minCost","totalCost","costCount","removeVertex","assert","n","pop","removeFace","f","vs","removeIfNonNeighbor","copy","add","normalize","tmpVertices","replaceVertex","least","constructor","computeNormal","addUniqueNeighbor","vA","vB","vC","subVectors","cross","oldv","newv","offset"],"sources":["/home/valentinalopez/Development/udeverso-react/node_modules/three/examples/jsm/modifiers/SimplifyModifier.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector2,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nconst _cb = new Vector3(), _ab = new Vector3();\n\nclass SimplifyModifier {\n\n\tmodify( geometry, count ) {\n\n\t\tgeometry = geometry.clone();\n\n\t\t// currently morphAttributes are not supported\n\t\tdelete geometry.morphAttributes.position;\n\t\tdelete geometry.morphAttributes.normal;\n\t\tconst attributes = geometry.attributes;\n\n\t\t// this modifier can only process indexed and non-indexed geomtries with at least a position attribute\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tif ( name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color' ) geometry.deleteAttribute( name );\n\n\t\t}\n\n\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\tconst vertices = [];\n\t\tconst faces = [];\n\n\t\t// add vertices\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst uvAttribute = geometry.getAttribute( 'uv' );\n\t\tconst normalAttribute = geometry.getAttribute( 'normal' );\n\t\tconst tangentAttribute = geometry.getAttribute( 'tangent' );\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\tlet t = null;\n\t\tlet v2 = null;\n\t\tlet nor = null;\n\t\tlet col = null;\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\n\t\t\tif ( uvAttribute ) {\n\n\t\t\t\tv2 = new Vector2().fromBufferAttribute( uvAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( normalAttribute ) {\n\n\t\t\t\tnor = new Vector3().fromBufferAttribute( normalAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( tangentAttribute ) {\n\n\t\t\t\tt = new Vector4().fromBufferAttribute( tangentAttribute, i );\n\n\t\t\t}\n\n\t\t\tif ( colorAttribute ) {\n\n\t\t\t\tcol = new THREE.Color().fromBufferAttribute( colorAttribute, i );\n\n\t\t\t}\n\n\t\t\tconst vertex = new Vertex( v, v2, nor, t, col );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tlet index = geometry.getIndex();\n\n\t\tif ( index !== null ) {\n\n\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\tconst a = i;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tlet nextVertex;\n\n\t\tlet z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tconst simplifiedGeometry = new BufferGeometry();\n\t\tconst position = [];\n\t\tconst uv = [];\n\t\tconst normal = [];\n\t\tconst tangent = [];\n\t\tconst color = [];\n\n\t\tindex = [];\n\n\t\t//\n\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\t\t\tposition.push( vertex.position.x, vertex.position.y, vertex.position.z );\n\t\t\tif ( vertex.uv ) {\n\n\t\t\t\tuv.push( vertex.uv.x, vertex.uv.y );\n\n\t\t\t}\n\n\t\t\tif ( vertex.normal ) {\n\n\t\t\t\tnormal.push( vertex.normal.x, vertex.normal.y, vertex.normal.z );\n\n\t\t\t}\n\n\t\t\tif ( vertex.tangent ) {\n\n\t\t\t\ttangent.push( vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w );\n\n\t\t\t}\n\n\t\t\tif ( vertex.color ) {\n\n\t\t\t\tcolor.push( vertex.color.r, vertex.color.g, vertex.color.b );\n\n\t\t\t}\n\n\n\t\t\t// cache final index to GREATLY speed up faces reconstruction\n\t\t\tvertex.id = i;\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\n\n\t\t}\n\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tif ( uv.length > 0 ) simplifiedGeometry.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\t\tif ( normal.length > 0 ) simplifiedGeometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\n\t\tif ( tangent.length > 0 ) simplifiedGeometry.setAttribute( 'tangent', new Float32BufferAttribute( tangent, 4 ) );\n\t\tif ( color.length > 0 ) simplifiedGeometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\n\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t}\n\n}\n\nfunction pushIfUnique( array, object ) {\n\n\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n}\n\nfunction removeFromArray( array, object ) {\n\n\tconst k = array.indexOf( object );\n\tif ( k > - 1 ) array.splice( k, 1 );\n\n}\n\nfunction computeEdgeCollapseCost( u, v ) {\n\n\t// if we collapse edge uv by moving u to v then how\n\t// much different will the model change, i.e. the \"error\".\n\n\tconst edgelength = v.position.distanceTo( u.position );\n\tlet curvature = 0;\n\n\tconst sideFaces = [];\n\n\t// find the \"sides\" triangles that are on the edge uv\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tconst face = u.faces[ i ];\n\n\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\tsideFaces.push( face );\n\n\t\t}\n\n\t}\n\n\t// use the triangle facing most away from the sides\n\t// to determine our curvature term\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tlet minCurvature = 1;\n\t\tconst face = u.faces[ i ];\n\n\t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\tconst sideFace = sideFaces[ j ];\n\t\t\t// use dot product of face normals.\n\t\t\tconst dotProd = face.normal.dot( sideFace.normal );\n\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t}\n\n\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t}\n\n\t// crude approach in attempt to preserve borders\n\t// though it seems not to be totally correct\n\tconst borders = 0;\n\n\tif ( sideFaces.length < 2 ) {\n\n\t\t// we add some arbitrary cost for borders,\n\t\t// borders += 10;\n\t\tcurvature = 1;\n\n\t}\n\n\tconst amt = edgelength * curvature + borders;\n\n\treturn amt;\n\n}\n\nfunction computeEdgeCostAtVertex( v ) {\n\n\t// compute the edge collapse cost for all edges that start\n\t// from vertex v.  Since we are only interested in reducing\n\t// the object by selecting the min cost edge at each step, we\n\t// only cache the cost of the least cost edge at this vertex\n\t// (in member variable collapse) as well as the value of the\n\t// cost (in member variable collapseCost).\n\n\tif ( v.neighbors.length === 0 ) {\n\n\t\t// collapse if no neighbors.\n\t\tv.collapseNeighbor = null;\n\t\tv.collapseCost = - 0.01;\n\n\t\treturn;\n\n\t}\n\n\tv.collapseCost = 100000;\n\tv.collapseNeighbor = null;\n\n\t// search all neighboring edges for \"least cost\" edge\n\tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.collapseCost = collapseCost;\n\t\t\tv.minCost = collapseCost;\n\t\t\tv.totalCost = 0;\n\t\t\tv.costCount = 0;\n\n\t\t}\n\n\t\tv.costCount ++;\n\t\tv.totalCost += collapseCost;\n\n\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.minCost = collapseCost;\n\n\t\t}\n\n\t}\n\n\t// we average the cost of collapsing at this vertex\n\tv.collapseCost = v.totalCost / v.costCount;\n\t// v.collapseCost = v.minCost;\n\n}\n\nfunction removeVertex( v, vertices ) {\n\n\tconsole.assert( v.faces.length === 0 );\n\n\twhile ( v.neighbors.length ) {\n\n\t\tconst n = v.neighbors.pop();\n\t\tremoveFromArray( n.neighbors, v );\n\n\t}\n\n\tremoveFromArray( vertices, v );\n\n}\n\nfunction removeFace( f, faces ) {\n\n\tremoveFromArray( faces, f );\n\n\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t// TODO optimize this!\n\tconst vs = [ f.v1, f.v2, f.v3 ];\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst v1 = vs[ i ];\n\t\tconst v2 = vs[ ( i + 1 ) % 3 ];\n\n\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\tv1.removeIfNonNeighbor( v2 );\n\t\tv2.removeIfNonNeighbor( v1 );\n\n\t}\n\n}\n\nfunction collapse( vertices, faces, u, v ) {\n\n\t// Collapse the edge uv by moving vertex u onto v\n\n\tif ( ! v ) {\n\n\t\t// u is a vertex all by itself so just delete it..\n\t\tremoveVertex( u, vertices );\n\t\treturn;\n\n\t}\n\n\tif ( v.uv ) {\n\n\t\tu.uv.copy( v.uv );\n\n\t}\n\n\tif ( v.normal ) {\n\n\t\tv.normal.add( u.normal ).normalize();\n\n\t}\n\n\tif ( v.tangent ) {\n\n\t\tv.tangent.add( u.tangent ).normalize();\n\n\t}\n\n\tconst tmpVertices = [];\n\n\tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t}\n\n\n\t// delete triangles on edge uv:\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tif ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t}\n\n\t}\n\n\t// update remaining triangles to have v instead of u\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t}\n\n\n\tremoveVertex( u, vertices );\n\n\t// recompute the edge collapse costs in neighborhood\n\tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t}\n\n}\n\n\n\nfunction minimumCostEdge( vertices ) {\n\n\t// O(n * n) approach. TODO optimize this\n\n\tlet least = vertices[ 0 ];\n\n\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\tleast = vertices[ i ];\n\n\t\t}\n\n\t}\n\n\treturn least;\n\n}\n\n// we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n\n\tconstructor( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tcomputeNormal() {\n\n\t\tconst vA = this.v1.position;\n\t\tconst vB = this.v2.position;\n\t\tconst vC = this.v3.position;\n\n\t\t_cb.subVectors( vC, vB );\n\t\t_ab.subVectors( vA, vB );\n\t\t_cb.cross( _ab ).normalize();\n\n\t\tthis.normal.copy( _cb );\n\n\t}\n\n\thasVertex( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t}\n\n\treplaceVertex( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t}\n\n}\n\nclass Vertex {\n\n\tconstructor( v, uv, normal, tangent, color ) {\n\n\t\tthis.position = v;\n\t\tthis.uv = uv;\n\t\tthis.normal = normal;\n\t\tthis.tangent = tangent;\n\t\tthis.color = color;\n\n\t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\taddUniqueNeighbor( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t}\n\n\tremoveIfNonNeighbor( n ) {\n\n\t\tconst neighbors = this.neighbors;\n\t\tconst faces = this.faces;\n\n\t\tconst offset = neighbors.indexOf( n );\n\n\t\tif ( offset === - 1 ) return;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t}\n\n}\n\nexport { SimplifyModifier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}